////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2019 Privategrity Corporation                                   /
//                                                                             /
// All rights reserved.                                                        /
////////////////////////////////////////////////////////////////////////////////

package cryptops

import (
	"fmt"
	"gitlab.com/elixxir/crypto/csprng"
	"gitlab.com/elixxir/crypto/cyclic"
	"gitlab.com/elixxir/crypto/large"
	"os"
	"testing"
)

var prime *large.Int
var grp *cyclic.Group

func TestMain(m *testing.M) {
	prime = large.NewIntFromString(MODP4096, 16)
	grp = cyclic.NewGroup(prime, large.NewInt(5), large.NewInt(53))
	os.Exit(m.Run())
}

// Tests that Generate conforms to the cryptops interface
func TestGeneratePrototype_CryptopsInterface(t *testing.T) {
	var emptyInterface interface{}
	var cryptop Cryptop

	emptyInterface = Generate
	cryptop, ok := emptyInterface.(Cryptop)
	_, ok2 := cryptop.(GeneratePrototype)

	if !(ok && ok2) {
		t.Errorf("GeneratePrototype() does not conform to the cryptops interface")
	}
}

// Tests that GetInputSize() returns the correct minimum input size.
func TestGeneratePrototype_GetInputSize(t *testing.T) {
	expect := uint32(1)
	actual := Generate.GetInputSize()

	if actual != expect {
		t.Errorf("GetInputSize() for GeneratePrototype did not return the "+
			"correct minimum input size\n\trecieved: %v\n\texpected: %v",
			actual, expect)
	}

}

// Tests that GetName() returns the correct name.
func TestGeneratePrototype_GetName(t *testing.T) {
	expect := "Generate"
	actual := Generate.GetName()

	if actual != expect {
		t.Errorf("GetName() for GeneratePrototype did not return the "+
			"name\n\trecieved: %v\n\texpected: %v",
			actual, expect)
	}
}

const MODP4096 = "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1" +
	"29024E088A67CC74020BBEA63B139B22514A08798E3404DD" +
	"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245" +
	"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED" +
	"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D" +
	"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F" +
	"83655D23DCA3AD961C62F356208552BB9ED529077096966D" +
	"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B" +
	"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9" +
	"DE2BCBF6955817183995497CEA956AE515D2261898FA0510" +
	"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64" +
	"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7" +
	"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B" +
	"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C" +
	"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31" +
	"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7" +
	"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA" +
	"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6" +
	"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED" +
	"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9" +
	"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199" +
	"FFFFFFFFFFFFFFFF"

// RNG type that alwyas returns bytes of value 2
type Rng2 struct{}

func NewRng42() csprng.Source { return &Rng2{} }
func (s *Rng2) Read(b []byte) (int, error) {
	for i := 0; i < len(b); i++ {
		b[i] = 2
	}
	return len(b), nil
}
func (s *Rng2) SetSeed(seed []byte) error { return nil }

// TestGenerate_Basic tests that the basic generation works
func TestGenerate_Basic(t *testing.T) {
	rng := NewRng42()

	var phaseKey, shareKey *cyclic.Int
	phaseKey = grp.NewInt(1)
	shareKey = grp.NewInt(1)

	err := Generate(grp, phaseKey, shareKey, rng)

	if err != nil {
		t.Errorf("Unexpected error testing generate: %s", err)
	}

	if len(phaseKey.Bytes()) != len(prime.Bytes()) {
		t.Errorf("phaseKey improper generated byte length: %d",
			len(phaseKey.Bytes()))
	}
	if len(shareKey.Bytes()) != 32 {
		t.Errorf("shareKey improper generated byte length: %d",
			len(phaseKey.Bytes()))
	}
}

// RNG type that alwyas returns bytes of value 0
type Rng0 struct {
	callCnt int
}

func NewRng0() csprng.Source { return &Rng0{} }
func (s *Rng0) Read(b []byte) (int, error) {
	if s.callCnt == 1 {
		return 0, fmt.Errorf("2nd call")
	}
	s.callCnt = 1
	for i := 0; i < len(b); i++ {
		b[i] = 0
	}
	return len(b), nil
}
func (s *Rng0) SetSeed(seed []byte) error { return nil }

// TestGenerate_0 tests that the generation fails on a 0 return
func TestGenerate_0(t *testing.T) {
	rng := NewRng0()

	var phaseKey, shareKey *cyclic.Int
	phaseKey = grp.NewInt(1)
	shareKey = grp.NewInt(1)

	err := Generate(grp, phaseKey, shareKey, rng)

	if err == nil {
		t.Errorf("Unexpected non-error testing generate on 0 return!")
	}
}

// RNG type that always returns and error on the 3rd byte read
type RngErr struct{}

func NewRngErr() csprng.Source { return &RngErr{} }
func (s *RngErr) Read(b []byte) (int, error) {
	if len(b) >= 3 {
		b[0] = 0
		b[1] = 1
		b[2] = 2
	}
	return 3, fmt.Errorf("Dummy error")
}
func (s *RngErr) SetSeed(seed []byte) error { return nil }

// TestGenerate_Err tests that the generation fails on error
func TestGenerate_Err(t *testing.T) {
	rng := NewRngErr()

	var phaseKey, shareKey *cyclic.Int
	phaseKey = grp.NewInt(1)
	shareKey = grp.NewInt(1)

	err := Generate(grp, phaseKey, shareKey, rng)

	if err == nil {
		t.Errorf("Unexpected non-error testing generate on Err return!")
	}
}

// RNG type that returns an error when more than 32 bytes are read
type RngErr32 struct{}

func NewRngErr32() csprng.Source { return &RngErr32{} }
func (s *RngErr32) Read(b []byte) (int, error) {
	if len(b) > 32 {
		return 0, fmt.Errorf("dummy")
	}
	for i := 0; i < len(b); i++ {
		b[i] = 42
	}
	fmt.Println("length genrated: ", len(b))
	return len(b), nil
}
func (s *RngErr32) SetSeed(seed []byte) error { return nil }

// TestGenerate_Err tests that the generation fails on error generating 2nd key
func TestGenerate_Err2(t *testing.T) {
	rng := NewRngErr32()

	var phaseKey, shareKey *cyclic.Int
	phaseKey = grp.NewInt(1)
	shareKey = grp.NewInt(1)

	err := Generate(grp, phaseKey, shareKey, rng)

	if err == nil {
		t.Errorf("Unexpected non-error testing generate on Err2 return!")
	}
}

// RNG type that always returns bytecount - 3
type RngBadCount struct{}

func NewRngBadCount() csprng.Source { return &RngBadCount{} }
func (s *RngBadCount) Read(b []byte) (int, error) {
	return len(b) - 3, nil
}
func (s *RngBadCount) SetSeed(seed []byte) error { return nil }

// TestGenerate_Cnt tests that the generation fails on bad bytecounts
func TestGenerate_Cnt(t *testing.T) {
	rng := NewRngBadCount()

	var phaseKey, shareKey *cyclic.Int
	phaseKey = grp.NewInt(1)
	shareKey = grp.NewInt(1)

	err := Generate(grp, phaseKey, shareKey, rng)

	if err == nil {
		t.Errorf("Unexpected non-error testing generate on Err return!")
	}
}
